#!/usr/bin/env python
# lrna-qc 0.0.1
# Generated by dx-app-wizard.
#
# Parallelized execution pattern: Your app will generate multiple jobs
# to perform some computation in parallel, followed by a final
# "postprocess" stage that will perform any additional computations as
# necessary.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import subprocess
import logging

logger = logging.getLogger("Applet")

@dxpy.entry_point("postprocess")
def postprocess(process_outputs):
    # Change the following to process whatever input this stage
    # receives.  You may also want to copy and paste the logic to download
    # and upload files here as well if this stage receives file input
    # and/or makes file output.

    for output in process_outputs:
        pass

    return { "answer": "placeholder value" }

@dxpy.entry_point("process")
def process(rep1_quant_file, rep2_quant_file):
    # Change the following to process whatever input this stage
    # receives.  You may also want to copy and paste the logic to download
    # and upload files here as well if this stage receives file input
    # and/or makes file output.

    rep1_quants = dxpy.DXFile(rep1_quant_file)
    rep2_quants = dxpy.DXFile(rep2_quant_file)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(rep1_quants.get_id(), "rep1_quants")

    dxpy.download_dxfile(rep2_quants.get_id(), "rep2_quants")
    logger.debug("Run MAD.R")
    mad_output = subprocess.check_output(['Rscript', '/usr/bin/MAD.R', 'rep1_quants', 'rep2_quants'])

    logger.debug(mad_output)
    logger.debug("Upload Plot")
    filename = rep1_quants.name + '_' + rep2_quants.name + '_MAPlot.png'
    subprocess.check_call(['mv', "MAPlot.png", filename])

    plot_dxfile = dxpy.upload_local_file(filename)

    return {"output": mad_output, "plot": plot_dxfile}

@dxpy.entry_point("main")
def main(rep1_quants, rep2_quants):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.


    # Split your work into parallel tasks.  As an example, the
    # following generates 10 subjobs running with the same dummy
    # input.

    subjobs = []
    if len(rep1_quants) != len(rep2_quants):
        raise

    for (rep1, rep2) in zip(rep1_quants, rep2_quants):
        subjob_input = { "req1_quant_file": rep1, "rep2_quant_file": rep2 }
        subjobs.append(dxpy.new_dxjob(subjob_input, "process"))

    # The following line creates the job that will perform the
    # "postprocess" step of your app.  We've given it an input field
    # that is a list of job-based object references created from the
    # "process" jobs we just created.  Assuming those jobs have an
    # output field called "output", these values will be passed to the
    # "postprocess" job.  Because these values are not ready until the
    # "process" jobs finish, the "postprocess" job WILL NOT RUN until
    # all job-based object references have been resolved (i.e. the
    # jobs they reference have finished running).
    #
    # If you do not plan to have the "process" jobs create output that
    # the "postprocess" job will require, then you can explicitly list
    # the dependencies to wait for those jobs to finish by setting the
    # "depends_on" field to the list of subjobs to wait for (it
    # accepts either dxpy handlers or string IDs in the list).  We've
    # included this parameter in the line below as well for
    # completeness, though it is unnecessary if you are providing
    # job-based object references in the input that refer to the same
    # set of jobs.

    output = {
                    "mad_plots": [dxpy.dxlink(subjob.get_output_ref("plot")) for subjob in subjobs],
                    "qc_metrics_json": [subjob.get_output_ref("output") for subjob in subjobs]
    }

    return output

dxpy.run()
